<!-- HTML header for doxygen 1.11.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4C: P4 Compiler Intermediate representation</title>
<link rel="icon" href="p4-fav.svg" type="image/svg+xml"  />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__2home_2runner_2work_2p4c_2p4c_2docs_2_i_r.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">P4 Compiler Intermediate representation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md14"></a> </p>
<h1><a class="anchor" id="autotoc_md15"></a>
Introduction</h1>
<p>This document outlines the design of the P4_16 compiler. It lays out the various classes and data structures used for the compiler and describes the general flow of the compilation process. The compiler is designed to operate in the `traditional’ manner, converting the source <a class="el" href="namespace_p4.html">P4</a> program to an internal representation, the performing a series of transformational passes on the IR, culminating in an IR representation that maps more or less directly to the target code. Along the way, the set of IR classes present in the code may change, with certain constructs appearing only in the initial IR from the parser, and other constructs being introduced through the compilation process.</p>
<p>Novel to this design is the ability to always return to an earlier version of the IR (backtracking across passes) or use multiple threads to operate on the IR, allowing different strategies to be tried in the search for a final result. Allowing this forking and backtracking is central to the IR and transformation design. The IR is designed to represent the program as a tree or DAG from a single root node, with each node referring only to its children. Transformations operate by creating new IR nodes that are shallow copies of existing nodes, and then creating new parent nodes to refer to these new nodes, up to the root of the IR. The internal representation is designed in C++ around a single inheritance object hierarchy with an ultimate base Node type used by all subclasses. The base Node class supports the functionality needed for visitor transformations – clone, equality tests, and subclass dispatch.</p>
<p>The IR needs to be extensible, allowing for the addition of new classes to the hierarchy as support for new targets is added. The initial IR produced by the parser contains constructs that are related only to the source <a class="el" href="namespace_p4.html">P4</a> language, and there will be frontend transformation passes that convert things to a simpler and more canonical form.</p>
<p>The IR may be a tree or DAG, but allowing back/up references in the IR (cycles) defeats much of the benefit of the immutable IR. If cycles (for example, leaf nodes for names directly referring to the named object) were allowed, pretty much any minor transform would end up cloning the entire IR graph, as modifying a leaf involves cloning the object containing the leaf, and then any object referring to that object, recursively.</p>
<h1><a class="anchor" id="autotoc_md16"></a>
Visitors and Transforms</h1>
<p>The compiler is organized as a series of <code><a class="el" href="class_visitor.html">Visitor</a></code> and <code><a class="el" href="class_transform.html">Transform</a></code> passes <a href="https://en.wikipedia.org/wiki/Visitor_pattern">Wikipedia</a>. The <code><a class="el" href="class_visitor.html">Visitor</a></code> and <code><a class="el" href="class_transform.html">Transform</a></code> base classes make defining new passes easy &ndash; a new transform need only specify the IR types it is interested in, and can ignore others. A (constant) <code><a class="el" href="class_visitor.html">Visitor</a></code> pass visits every node in the IR tree and accumulates information about the tree but does not modify it, while a <a class="el" href="class_transform.html">Transform</a> pass visits every node, possibly modifying the node or replacing it with some other node</p>
<div class="fragment"><div class="line">++</div>
<div class="line">   <span class="comment">/* pseudo-code for basic Transform visitor */</span></div>
<div class="line">   visit(node, context=ROOT, visited={}) {</div>
<div class="line">   <span class="keywordflow">if</span> (node in visited) {</div>
<div class="line">       <span class="keywordflow">if</span> (visited[node] == INVALID)</div>
<div class="line">           <span class="keywordflow">throw</span> loop_detected</div>
<div class="line">       <span class="keywordflow">if</span> (VisitDagOnce)</div>
<div class="line">           <span class="keywordflow">return</span> visited[node] }</div>
<div class="line">   visited[node] = INVALID</div>
<div class="line">   copy = shallow_clone(node)</div>
<div class="line">   <span class="keywordflow">if</span> (VisitDagOnce)</div>
<div class="line">       forward_children(copy, visited)</div>
<div class="line">   copy = preorder(copy, context) <span class="comment">// override in Transform subclass</span></div>
<div class="line">   visit_children(copy, {copy, context}, visited)</div>
<div class="line">   copy = postorder(copy, context) <span class="comment">// override in Transform subclass</span></div>
<div class="line">   <span class="keywordflow">if</span> (*copy == *node) {</div>
<div class="line">       visited[node] = node</div>
<div class="line">       <span class="keywordflow">return</span> node</div>
<div class="line">   } <span class="keywordflow">else</span> {</div>
<div class="line">       visited[node] = copy</div>
<div class="line">       <span class="keywordflow">return</span> copy }</div>
<div class="line">   }</div>
<div class="line">   forward_children(node, visited) {</div>
<div class="line">   <span class="keywordflow">for</span> (child in children(node))</div>
<div class="line">       <span class="keywordflow">if</span> (child in visited)</div>
<div class="line">           child = visited[child]</div>
<div class="line">   }</div>
<div class="line">   visit_children(node, context, visited) {</div>
<div class="line">   <span class="keywordflow">for</span> (child in children(node))</div>
<div class="line">       child = visit(child, context, visited)</div>
<div class="line">   }</div>
</div><!-- fragment --><p>A <code><a class="el" href="class_transform.html">Transform</a></code> pass is allowed to freely modify or completely replace a node in its preorder and postorder routines, and the <a class="el" href="class_transform.html">Transform</a> visitor will automatically rebuild the tree as needed. The transform subroutines cannot modify other nodes in the tree, however, though they may access and refer to them. These routines can be overloaded to differentiate between different IR subclasses automatically. Any given visitor need only override the routines it is interested in for the IR types it is interested in.</p>
<p>There are several <a class="el" href="class_visitor.html">Visitor</a> subclasses that describe different types of visitors:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><a class="el" href="class_visitor.html">Visitor</a>   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="class_inspector.html">Inspector</a></code>   </td><td class="markdownTableBodyNone">simplified visitor that does not modify any nodes, just collects information.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="class_modifier.html">Modifier</a></code>   </td><td class="markdownTableBodyNone">simplified visitor that does not change the tree/dag structure, but may modify nodes in place.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="class_transform.html">Transform</a></code>   </td><td class="markdownTableBodyNone">full transformation visitor described above    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="class_pass_manager.html">PassManager</a></code>   </td><td class="markdownTableBodyNone">combines several visitors, run in a sequence   </td></tr>
</table>
<p>There are also some interfaces that <a class="el" href="class_visitor.html">Visitor</a> subclasses can implement to alter how nodes are visited:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Interface   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code><a class="el" href="class_control_flow_visitor.html">ControlFlowVisitor</a></code>   </td><td class="markdownTableBodyNone">visit nodes in control-flow order, splitting (cloning) the visitor at conditions and merging the clone at join points    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code><a class="el" href="class_backtrack.html">Backtrack</a></code>   </td><td class="markdownTableBodyNone">visitor that is notified when backtracking occurs and can have its state saved as a backtrack point.   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md17"></a>
ControlFlowVisitor</h3>
<p>To support control flow analysis, there is a special <code><a class="el" href="class_control_flow_visitor.html">ControlFlowVisitor</a></code> interface that is understood by certain IR subclasses that encapsulate control flow, and is used by them to control the order in which children are visited and the visitor state passed to the visitor preorder/postorder routines in order to implement control-flow analysis.</p>
<p>The basic idea is that control flow IR nodes, when visiting their children, will create clones of the <code><a class="el" href="class_control_flow_visitor.html">ControlFlowVisitor</a></code> object to visit different children after a branch, and will then call <code>flow_merge</code> at the join point to merge the visitor state. Both the <code><a class="el" href="class_visitor.html">Visitor</a></code> base class and the <code><a class="el" href="class_control_flow_visitor.html">ControlFlowVisitor</a></code> interface define two virtual functions: <code>flow_clone</code> and <code>flow_merge</code> to mediate this. In the <code><a class="el" href="class_visitor.html">Visitor</a></code> base class (used by all visitors that do <em>not</em> inherit from the <code><a class="el" href="class_control_flow_visitor.html">ControlFlowVisitor</a></code> interface, these are implemented as no-ops &ndash; <code>flow_clone</code> just returns the same object, and <code>flow_merge</code> does nothing. In the <code><a class="el" href="class_control_flow_visitor.html">ControlFlowVisitor</a></code> interface <code>flow_clone</code> calls the <code>clone</code> function (which must be implemented by the leaf class) and <code>flow_merge</code> is an abstract virtual function that must be implemented by the leaf class.</p>
<p>As an example for how these are used in the IR visitor routines, the IR::If class has three children to visit &ndash; a predicate and two consequents, with the value of the predicate deciding which consequent to execute. The child visitor for <code>IR::If</code> is</p>
<div class="fragment"><div class="line">++</div>
<div class="line">   visitor.visit(predicate);</div>
<div class="line">   clone = visitor.flow_clone();</div>
<div class="line">   visitor.visit(ifTrue);</div>
<div class="line">   clone.visit(ifFalse);</div>
<div class="line">   visitor.flow_merge(clone);</div>
</div><!-- fragment --><p>So both consequents are visited with a visitor state that corresponds to the control flow immediately after evaluating the predicate, and then the control flow state after both consequents are merged back together.</p>
<p>In order to make use of this functionality, a <code><a class="el" href="class_visitor.html">Visitor</a></code> sub class need only inherit from the <code><a class="el" href="class_control_flow_visitor.html">ControlFlowVisitor</a></code> interface and implement the <code>clone</code> and <code>flow_merge</code> routines. Other <code><a class="el" href="class_visitor.html">Visitor</a></code> classes don't need to do anything, but may want to implement <code>clone</code> for other reasons.</p>
<p>This control flow analysis only works for branch-and-join control flow &ndash; it is not adequate for loops (which generally requires an iterate to fixed point process). As our IR does not (currently) support loops this is fine. Since <a class="el" href="namespace_p4.html">P4</a> does not allow loops in the match-action part of the pipeline, this works well there, but may be inadequate for parsers, which can support loops.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Overall flow</h1>
<p>The compiler flow can be roughly split into frontend, middle-end, and backend. The frontend does largely non-target specific transforms designed to clean up the IR and get it into a canonical form. The middle make target-dependent IR transformations. The back end performs resource allocation decisions. As this backend step may fail due to constraint violations, it may need to backtrack through the middle-end to try a different configuration. We do not anticipate needing to backtrack through frontend passes. The split between Front/Middle/Back-end is largely arbitrary, and some passes may end up being moved between them if we later find it makes more sense to do so.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Frontend</h2>
<p>The frontend parses the source code into IR that corresponds directly to the source code. It then runs a series of passes like type-checking (modifying nodes to indicate their inferred types), constant folding, dead code elimination, etc. The initial IR tree corresponds to the source code, and then various mostly target independent transformation are done. Complex scoping or structuring in the code is flattened here.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Mid-end</h2>
<p>The mid-end is where transformations that depend somewhat on the target, but are not specific resource allocations, take place. At some point the mid-end transforms the IR into a form that matches the target capabilities.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
Pass Managers</h2>
<p>To manage backtracking and control the order of passes and transforms, we use a <code><a class="el" href="class_pass_manager.html">PassManager</a></code> object which encapsulates a sequence of passes and runs them in order. Those passes that support the <code><a class="el" href="class_backtrack.html">Backtrack</a></code> interface are backtrack points.</p>
<p>The generic <code><a class="el" href="class_pass_manager.html">PassManager</a></code> can manage a dynamically chosen series of passes. It tracks passes that implement <code><a class="el" href="class_backtrack.html">Backtrack</a></code> and if a later pass fails, will backtrack to the <a class="el" href="class_backtrack.html">Backtrack</a> pass.</p>
<div class="fragment"><div class="line">interface Backtrack {</div>
<div class="line">   bool backtrack(trigger);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>backtrack</code> method is called when backtracking is triggered, with a trigger reason. Returns <code>true</code> if the pass can try a useful alternative, <code>false</code> if manager should search for some other backtracking point.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
Exception Use</h2>
<p>Exceptions are usable for errors that are reportable to the user, constraint problems that should result in backtracking and internal compiler problems. There are a number of exception classes designed for these purposes.</p>
<ul>
<li><code><a class="el" href="struct_backtrack_1_1trigger.html">Backtrack::trigger</a></code> Used to control backtracking. May be subclassed to attach additional information.</li>
<li><code>CompilerBug</code> Used for internal compiler errors. Use the BUG() macro wrapper instead of calling this directly.</li>
</ul>
<h1><a class="anchor" id="autotoc_md23"></a>
IR Classes</h1>
<p>To make IR class management and extension easier, IR classes are defined in .def files, which are processed by an ir-generator tool to produce the actual IR C++ code. Conceptually, these .def files are just C++ class definitions with the boilerplate removed, and the ir-generator program inserts the boilerplate and splits each class definition into .h and .cpp parts as needed.</p>
<p>The bulk of the "normal" IR is defined in the ir subdirectory, with some frontends and backends having their own extensions to the IR defined in their own ir subdirectories. The ir-generator tool takes reads all the .def files in the tree and constructs a single .h and .cpp file with all the IR class definition code.</p>
<p>All references to IR class objects from other IR class object MUST be as <code>const</code> pointers, to maintain the write-only invariants. Where that is too onerous, IR classes may be directly embedded in other IR objects, rather than by reference. When an IR object is embedded in this way, it becomes modifiable in <code><a class="el" href="class_modifier.html">Modifier</a></code>/<code><a class="el" href="class_transform.html">Transform</a></code> visitors when visiting the containing node, and will not be directly visited itself.</p>
<p>The ir-generator understands both of these mechanisms. Any field declared in an IR class with another IR class as a type will be made a <code>const</code> pointer, unless it has an <code>inline</code> modifier, in which case it will be a directly embedded sub-object.</p>
<p>The ir-generator understands a number of "standard" methods for IR classes &ndash; <code>visit_children</code>, <code>operator==</code>, <code>dbprint</code>, <code>toString</code>, <code>apply</code>. These methods can be declared <em>without</em> any arguments or return types (ie, just the method name followed by a {}-block of code), in which case the standard declaration will be synthesized. If the method is not declared in the .def file, a standard definition (based on the fields declared in the class) will be created. In this way, <em>most</em> classes can avoid including this boilerplate code in the .def file.</p>
<h3><a class="anchor" id="autotoc_md24"></a>
<code>IR::Node</code></h3>
<p>This is the ultimate abstract base class of all IR nodes and contains only a small amount of data for error reporting and debugging. In general, this info is NEVER compared for equality (so subclasses should never call Node::operator==`) as Nodes that differ only in this information should be considered equal, and not require cloning or the IR tree.</p>
<h3><a class="anchor" id="autotoc_md25"></a>
<code>IR::Vector&lt;T&gt;</code></h3>
<p>This template class holds a vector of (<code>const</code>) pointers to nodes of a particular <code><a class="el" href="class_i_r_1_1_node.html">IR::Node</a></code> subclass. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.11.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
