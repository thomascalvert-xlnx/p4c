<!-- HTML header for doxygen 1.11.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>P4C: eBPF Backend</title>
<link rel="icon" href="p4-fav.svg" type="image/svg+xml"  />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<!--  Add link to paragraphs   -->
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
  DoxygenAwesomeParagraphLink.init()
</script>
<!-- Add copy button to code fragments  -->
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeFragmentCopyButton.init()
</script>
<!-- Add dark mode toggle -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="p4-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">P4C
   </div>
   <div id="projectbrief">The P4 Compiler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__2home_2runner_2work_2p4c_2p4c_2backends_2ebpf_2_r_e_a_d_m_e.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">eBPF Backend</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md81"></a> The back-end accepts only P4_16 code written for the <code>ebpf_model.p4</code> or <code>xdp_model.p4</code> filter models. It generates C code that can be afterwards compiled into <a href="https://en.wikipedia.org/wiki/Berkeley_Packet_Filter">eBPF (extended Berkeley Packet Filters)</a> using clang/llvm or <a href="https://github.com/iovisor/bcc.git">bcc</a>.</p>
<p>An older version of this compiler for compiling P4_14 is available <a href="https://github.com/iovisor/bcc/tree/master/src/cc/frontends/p4">here</a> (historical reference only).</p>
<p>Identifiers starting with ebpf_ are reserved in <a class="el" href="namespace_p4.html">P4</a> programs, including for structure field names.</p>
<h1><a class="anchor" id="autotoc_md82"></a>
Target architectures</h1>
<p>The <code>ebpf_model.p4</code> target is a classifier-only: the program returns a boolean which controls whether the packet is passed or dropped. In <a class="el" href="namespace_p4.html">P4</a> terms, this means there is no deparser.</p>
<p>The <code>xdp_model.p4</code> target adds packet editing support, and is meant to replicate the capabilities of the Linux kernel's XDP environment. It can be viewed as an extension of the previous model which adds a deparser.</p>
<h1><a class="anchor" id="autotoc_md83"></a>
Background</h1>
<p>In this section we give a brief overview of <a class="el" href="namespace_p4.html">P4</a> and <a class="el" href="namespace_e_b_p_f.html">EBPF</a>. A detailed treatment of these topics is outside the scope of this text.</p>
<h2><a class="anchor" id="autotoc_md84"></a>
P4</h2>
<p><a href="http://p4.org">P4</a> is a domain-specific programming language for specifying the behavior of the dataplanes of network-forwarding elements. The name of the programming language comes from the title of a paper published in the proceedings of SIGCOMM Computer Communications Review in 2014: <a href="http://www.sigcomm.org/ccr/papers/2014/July/0000000.0000004">Programming Protocol-Independent Packet Processors</a></p>
<p><a class="el" href="namespace_p4.html">P4</a> itself is protocol-independent but allows programmers to express a rich set of data plane behaviors and protocols. This back-end only supports the newest version of the <a class="el" href="namespace_p4.html">P4</a> programming language, <a href="https://p4.org/specs">P4_16</a>. The core <a class="el" href="namespace_p4.html">P4</a> abstractions are:</p>
<ul>
<li>Headers describe the format (the set of fields and their sizes) of each header within a packet.</li>
<li>Parser (finite-state machines) describe the permitted header sequences within received packets.</li>
<li>Tables associate keys to actions. <a class="el" href="namespace_p4.html">P4</a> tables generalize traditional forwarding tables; they can be used to implement routing tables, flow lookup tables, access-control lists, etc.</li>
<li>Actions describe how packet header fields and metadata are manipulated.</li>
<li>Match-action units stitch together tables and actions, and perform the following sequence of operations:<ul>
<li>Construct lookup keys from packet fields or computed metadata,</li>
<li>Use the constructed lookup key to index into tables, choosing an action to execute,</li>
<li>Finally, execute the selected action.</li>
</ul>
</li>
<li>Control flow is expressed as an imperative program describing the data-dependent packet processing within a pipeline, including the data-dependent sequence of match-action unit invocations.</li>
</ul>
<p><a class="el" href="namespace_p4.html">P4</a> programs describe the behavior of network-processing dataplanes. A <a class="el" href="namespace_p4.html">P4</a> program is designed to operate in concert with a separate <em>control plane</em> program. The control plane is responsible for managing at runtime the contents of the <a class="el" href="namespace_p4.html">P4</a> tables. <a class="el" href="namespace_p4.html">P4</a> cannot be used to specify control-planes; however, a <a class="el" href="namespace_p4.html">P4</a> program implicitly specifies the interface between the data-plane and the control-plane.</p>
<h2><a class="anchor" id="autotoc_md85"></a>
eBPF</h2>
<h3><a class="anchor" id="autotoc_md86"></a>
Safe code</h3>
<p>eBPF is a acronym that stands for Extended Berkeley Packet Filters. In essence eBPF is a low-level programming language (similar to machine code); eBPF programs are traditionally executed by a virtual machine that resides in the Linux kernel. eBPF programs can be inserted and removed from a live kernel using dynamic code instrumentation. The main feature of eBPF programs is their <em>static safety</em>: prior to execution all eBPF programs have to be validated as being safe, and unsafe programs cannot be executed. A safe program provably cannot compromise the machine it is running on:</p>
<ul>
<li>it can only access a restricted memory region (on the local stack)</li>
<li>it can run only for a limited amount of time; during execution it cannot block, sleep or take any locks</li>
<li>it cannot use any kernel resources with the exception of a limited set of kernel services which have been specifically whitelisted, including operations to manipulate tables (described below)</li>
</ul>
<h3><a class="anchor" id="autotoc_md87"></a>
Kernel hooks</h3>
<p>eBPF programs are inserted into the kernel using <em>hooks</em>. There are several types of hooks available:</p>
<ul>
<li>any function entry point in the kernel can act as a hook; attaching an eBPF program to a function <code>foo()</code> will cause the eBPF program to execute every time some kernel thread executes <code>foo()</code>.</li>
<li>eBPF programs can also be attached using the Linux Traffic Control (<a class="el" href="namespace_t_c.html" title="This file defines functions for the pass to generate the introspection file.">TC</a>) subsystem, in the network packet processing datapath. Such programs can be used as <a class="el" href="namespace_t_c.html" title="This file defines functions for the pass to generate the introspection file.">TC</a> classifiers and actions.</li>
<li>eBPF programs can also be attached to sockets or network interfaces. In this case they can be used for processing packets that flow through the socket/interface.</li>
</ul>
<p>eBPF programs can be used for many purposes; the main use cases are dynamic tracing and monitoring, and packet processing. We are mostly interested in the latter use case in this document.</p>
<h3><a class="anchor" id="autotoc_md88"></a>
eBPF Tables</h3>
<p>The eBPF runtime exposes a bi-directional kernel-userspace data communication channel, called <em>tables</em> (also called maps in some eBPF documents and code samples). eBPF tables are essentially key-value stores, where keys and values are arbitrary fixed-size bitstrings. The key width, value width and table size (maximum number of entries that can be stored) are declared statically, at table creation time.</p>
<p>In user-space tables handles are exposed as file descriptors. Both user- and kernel-space programs can manipulate tables, by inserting, deleting, looking up, modifying, and enumerating entries in a table.</p>
<p>In kernel space the keys and values are exposed as pointers to the raw underlying data stored in the table, whereas in user-space the pointers point to copies of the data.</p>
<h3><a class="anchor" id="autotoc_md89"></a>
Concurrency</h3>
<p>An important aspect to understand related to eBPF is the execution model. An eBPF program is triggered by a kernel hook; multiple instances of the same kernel hook can be running simultaneously on different cores.</p>
<p>Each table however has a single instances across all the cores. A single table may be accessed simultaneously by multiple instances of the same eBPF program running as separate kernel threads on different cores. eBPF tables are native kernel objects, and access to the table contents is protected using the kernel RCU mechanism. This makes access to table entries safe under concurrent execution; for example, the memory associated to a value cannot be accidentally freed while an eBPF program holds a pointer to the respective value. However, accessing tables is prone to data races; since eBPF programs cannot use locks, some of these races often cannot be avoided.</p>
<p>eBPF and the associated tools are also under active development, and new capabilities are added frequently.</p>
<h1><a class="anchor" id="autotoc_md90"></a>
Compiling P4 to eBPF</h1>
<p>From the above description it is apparent that the <a class="el" href="namespace_p4.html">P4</a> and eBPF programming languages have different expressive powers. However, there is a significant overlap in their capabilities, in particular, in the domain of network packet processing. The following image illustrates the situation:</p>
<p><img src="scope.png" alt="P4 and eBPF overlap in capabilities" class="inline"/></p>
<p>We expect that the overlapping region will grow in size as both <a class="el" href="namespace_p4.html">P4</a> and eBPF continue to mature.</p>
<p>The current version of the <a class="el" href="namespace_p4.html">P4</a> to eBPF compiler translates programs written in the version P4_16 of the programming language to programs written in a restricted subset of C. The subset of C is chosen such that it should be compilable to eBPF using clang and/or <a href="https://github.com/iovisor/bcc">bcc (the BPF Compiler Collection)</a>.</p>
<div class="fragment"><div class="line">         --------------              -------</div>
<div class="line">P4 ---&gt;  | P4-to-eBPF | ---&gt; C ----&gt; | clang/BCC | --&gt; eBPF</div>
<div class="line">         --------------              -------</div>
</div><!-- fragment --><p>The <a class="el" href="namespace_p4.html">P4</a> program only describes the packet processing <em>data plane</em>, that runs in the Linux kernel. The <em>control plane</em> must be separately implemented by the user. BCC tools simplify this task considerably, by generating C and/or Python APIs that expose the dataplane/control-plane APIs.</p>
<h2><a class="anchor" id="autotoc_md91"></a>
Dependencies</h2>
<p>Our eBPF programs require a Linux kernel with version 4.15 or newer. The eBPF backend relies on <a href="https://github.com/libbpf/libbpf">libbpf</a>, which provides kernel- and distribution-independent header files. libbpf must be available in order to compile the generated eBPF C code into eBPF byte code. To install libbpf, run <code>python3 backends/ebpf/build_libbpf</code> in the p4c folder.</p>
<p>In addition the following packages and programs are required to run the full test suite:</p>
<ul>
<li>Clang 3.3 and llvm 3.7.1 or later are required. (Note: In some versions of Ubuntu Xenial (16.04.4) CMake crashes when checking for llvm. Until the bugfix is committed upstream, workarounds are available in <a href="https://github.com/p4lang/p4c/issues/1376">this issue</a>:</li>
<li>libpcap-dev to parse and generate .pcap files.</li>
<li>libelf-dev to compile C-programs to eBPF byte code.</li>
<li>zlib1g as libelf dependency.</li>
<li>a recent version of iproute2 that supports <code>clsact</code> to load eBPF programs via <code>tc</code> and <code>ip</code>.</li>
<li>net-tools (if not installed already)</li>
</ul>
<p>Additionally, the eBPF compiler test suite has the following python dependencies:</p>
<ul>
<li>The python iproute2 package to create virtual interfaces.</li>
<li>The python ply package to parse .stf testing files.</li>
<li>The python scapy package to read and write pcap files.</li>
</ul>
<p>You can install these using: </p><div class="fragment"><div class="line">$ sudo apt-get install clang llvm libpcap-dev libelf-dev iproute2 net-tools</div>
<div class="line">$ pip3 install --user pyroute2 ply==3.8 scapy==2.4.0</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md92"></a>
Supported capabilities</h2>
<p>The current version of the <a class="el" href="namespace_p4.html">P4</a> to eBPF compiler supports a relatively narrow subset of the <a class="el" href="namespace_p4.html">P4</a> language, but still powerful enough to write very complex packet filters and simple packet forwarding engines. We expect that the compiler's capabilities will improve gradually.</p>
<p>Here are some limitations imposed on the <a class="el" href="namespace_p4.html">P4</a> programs:</p>
<ul>
<li>arbitrary parsers can be compiled, but the BCC compiler will reject parsers that contain cycles</li>
<li>arithmetic on data wider than 32 bits is not supported</li>
<li>eBPF does not offer support for ternary table matches</li>
</ul>
<h2><a class="anchor" id="autotoc_md93"></a>
Translating P4 to C</h2>
<p>To simplify the translation, the <a class="el" href="namespace_p4.html">P4</a> programmer should refrain using identifiers whose name starts with <code>ebpf_</code>.</p>
<p>The following table provides a brief summary of how each <a class="el" href="namespace_p4.html">P4</a> construct is mapped to a corresponding C construct:</p>
<h3><a class="anchor" id="autotoc_md94"></a>
Translating parsers</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><a class="el" href="namespace_p4.html">P4</a> Construct   </th><th class="markdownTableHeadNone">C Translation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>header</code>   </td><td class="markdownTableBodyNone"><code>struct</code> type with an additional <code>valid</code> bit    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>struct</code>   </td><td class="markdownTableBodyNone"><code>struct</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">parser state   </td><td class="markdownTableBodyNone">code block    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">state transition   </td><td class="markdownTableBodyNone"><code>goto</code> statement    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>extract</code>   </td><td class="markdownTableBodyNone">load/shift/mask data from packet buffer   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md95"></a>
Translating match-action pipelines</h3>
<h1><a class="anchor" id="autotoc_md96"></a>
autotoc_md96</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><a class="el" href="namespace_p4.html">P4</a> Construct   </th><th class="markdownTableHeadNone">C Translation    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">table   </td><td class="markdownTableBodyNone">2 eBPF tables: second one used just for the default action    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">table key   </td><td class="markdownTableBodyNone"><code>struct</code> type    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">table <code>actions</code> block   </td><td class="markdownTableBodyNone">tagged <code>union</code> with all possible actions    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>action</code> arguments   </td><td class="markdownTableBodyNone"><code>struct</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">table <code>reads</code>   </td><td class="markdownTableBodyNone">eBPF table access    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>action</code> body   </td><td class="markdownTableBodyNone">code block    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">table <code>apply</code>   </td><td class="markdownTableBodyNone"><code>switch</code> statement    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">counters   </td><td class="markdownTableBodyNone">additional eBPF table   </td></tr>
</table>
<h3><a class="anchor" id="autotoc_md97"></a>
Generating code from a .p4 file</h3>
<p>The C code can be generated using the following command:</p>
<p><code>p4c-ebpf PROGRAM.p4 -o out.c</code></p>
<p>This will generate the C-file and its corresponding header. The architecture (ebpf_model or xdp_model) is auto-detected.</p>
<h3><a class="anchor" id="autotoc_md98"></a>
Using the generated code</h3>
<p>The resulting file contains the complete data structures, tables, and a C function named <code>ebpf_filter</code> that implements the P4-specified data-plane. This C file can be manipulated using clang or BCC tools; please refer to the BCC project documentation and sample test files of the <a class="el" href="namespace_p4.html">P4</a> to eBPF source code for an in-depth understanding.</p>
<p>The general C-file alone will not compile. It depends on headers specific to the generated target. For the default target, this is the <code>kernel_ebpf.h</code> file which can be found in the <a class="el" href="namespace_p4.html">P4</a> backend under <code>p4c/backends/ebpf/runtime</code>. The <a class="el" href="namespace_p4.html">P4</a> backend also provides a makefile and sample header which allow for quick generation and automatic compilation of the generated file.</p>
<p><code>make -f p4c/backends/ebpf/runtime/kernel.mk BPFOBJ=out.o P4FILE=PROGRAM.p4</code></p>
<p>where -f path is the path to the makefile, BPFOBJ is the output ebpf byte code and P4FILE is the input <a class="el" href="namespace_p4.html">P4</a> program. This command sequence will generate an eBPF program, which can be loaded into the kernel using <a class="el" href="namespace_t_c.html" title="This file defines functions for the pass to generate the introspection file.">TC</a>.</p>
<h4><a class="anchor" id="autotoc_md99"></a>
Connecting the generated program with the TC</h4>
<p>The eBPF code that is generated is can be used as a classifier attached to the ingress packet path using the Linux <a class="el" href="namespace_t_c.html" title="This file defines functions for the pass to generate the introspection file.">TC</a> subsystem. The same eBPF code should be attached to all interfaces. Note however that all eBPF code instances share a single set of tables, which are used to control the program behavior.</p>
<p><code>tc qdisc add dev IFACE clsact</code></p>
<p>Creates a classifier qdisc on the respective interface. Once created, eBPF programs can be attached to it using the following command:</p>
<p><code>tc filter add dev IFACE egress bpf da obj YOUREBPFCODE section prog verbose</code></p>
<p><code>da</code> implies that tc takes action input directly from the return codes provided by the eBPF program. We currently support <code>TC_ACT_SHOT</code> and <code>TC_ACT_OK</code>. More information avaiable <a href="http://docs.cilium.io/en/latest/bpf/#tc-traffic-control">here</a>.</p>
<h1><a class="anchor" id="autotoc_md100"></a>
How to run the generated eBPF program</h1>
<p>Once the eBPF program is loaded, various methods exist to manipulate the tables. The easiest and simplest way is to use the <a href="http://docs.cilium.io/en/latest/bpf/#bpftool">bpftool</a> provided by the kernel.</p>
<p>An alternative is to use explicit syscalls (an example can be found in the <a href="https://github.com/torvalds/linux/blob/master/tools/lib/bpf/bpf.c">kernel tools folder</a>.</p>
<p>The <a class="el" href="namespace_p4.html">P4</a> compiler automatically provides a set of table initializers, which may also serve as example, in the header of the generated C-file.</p>
<p>The following tests run ebpf programs:</p>
<ul>
<li><code>make check-ebpf</code>: runs the basic ebpf user-space tests</li>
<li><code>make check-ebpf-bcc</code>: runs the user-space tests using bcc to compile ebpf</li>
<li><code>sudo -E make check-ebpf-kernel</code>: runs the kernel-level tests. Requires root privileges to install the ebpf program in the Linux kernel. Note: by default the kernel ebpf tests are disabled; if you want to enable them you can modify the file <code>backends/ebpf/CMakeLists.txt</code> by setting this variable to <code>True</code>: <code>set (SUPPORTS_KERNEL True)</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md101"></a>
How to inject custom extern function to the generated eBPF program?</h1>
<p>The <a class="el" href="namespace_p4.html">P4</a> to eBPF compiler comes with the support for custom C extern functions. It means that a developer can write a custom, eBPF-compatible (acceptable by BPF verifier) C function and call it from the <a class="el" href="namespace_p4.html">P4</a> program as a normal <a class="el" href="namespace_p4.html">P4</a> action. As a result, <a class="el" href="namespace_p4.html">P4</a> program can be extended with functionality, which is not supported natively by the <a class="el" href="namespace_p4.html">P4</a> language. This feature is briefly described below.</p>
<h2><a class="anchor" id="autotoc_md102"></a>
Basic principles</h2>
<p>The C extern function can effectively enhance the functionality of <a class="el" href="namespace_p4.html">P4</a> program. A programmer should be able to write own function, declare it in the <a class="el" href="namespace_p4.html">P4</a> program and invoke from within <a class="el" href="namespace_p4.html">P4</a> action or <a class="el" href="namespace_p4.html">P4</a> control block.</p>
<p>The C extern can use BPF helpers in order to make syscalls to eBPF subsystem. In particular, the C extern can define and have control over its own set of BPF maps. However, the C extern must not read or write to BPF maps implementing <a class="el" href="namespace_p4.html">P4</a> tables and used by the main <a class="el" href="namespace_p4.html">P4</a> program.</p>
<p>The C extern could be also allowed to access packet’s payload, but this feature is not implemented in the first version of the C Custom Externs feature.</p>
<h2><a class="anchor" id="autotoc_md103"></a>
Definition</h2>
<p>The custom C extern function should be explicitly declared in the <a class="el" href="namespace_p4.html">P4</a> program making use of that extern. For example:</p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">bool</span> verify_ipv4_checksum(in IPv4_h iphdr);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md104"></a>
Compilation</h2>
<p>The <code>--emit-externs</code> flag must be appended to the <code>p4c-ebpf</code> compiler to instruct it that there are some C extern functions defined in the <a class="el" href="namespace_p4.html">P4</a> program and compiler should not warn about them.</p>
<div class="fragment"><div class="line">p4c-ebpf -o OUTPUT.c PROGRAM.p4 --emit-externs</div>
</div><!-- fragment --><p>Furthermore, the C file including definition of the C extern function should be provided to <code>clang</code>:</p>
<div class="fragment"><div class="line">clang -O2 -include C-EXTERN-FILE.c -target bpf -c OUTPUT.c -o OUTPUT.o</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md105"></a>
Calling convention</h2>
<ul>
<li>Basic types are converted from <a class="el" href="namespace_p4.html">P4</a> representation to C representation as follows:<ul>
<li>fields shorter than 64 bits are rounded up to the nearest C unsigned integer (e.g. bit&lt;1&gt; → u8, bit&lt;48&gt; → u64).</li>
<li>fields wider than 64 bits are converted to the array of u8. If the field has custom width (e.g. 123 bits) the last element of the array is also u8 (according to the first rule). For example, IPv6 address is converted from bit&lt;128&gt; to u8[16].</li>
<li><b>Boolean (bool)</b> type is converted to u8.</li>
<li><b>header</b> type is converted to C structure. The rules above are applied to each field of a header. Moreover, each C structure representing <b>header</b> type contains additional valid bit field, implemented as u8.</li>
<li><b>struct</b> type is converted to C structure. The rules above are applied to each field of a struct.</li>
</ul>
</li>
<li>A direction of parameter passed to C extern function is handled as follows:<ul>
<li><b>in</b> parameters are prepended with “const” qualifier in C and are passed by value to C extern function.</li>
<li><b>inout</b> parameters are are passed by reference to C extern function.</li>
<li><b>out</b> parameters are passed by reference to C extern function.</li>
</ul>
</li>
<li><p class="startli">Using BPF maps:</p><ul>
<li>BPF maps can be defined inside the C extern function to provide statefulness. BPF map can be defined as follows:</li>
</ul>
<div class="fragment"><div class="line">REGISTER_START()</div>
<div class="line">REGISTER_TABLE(&lt;NAME&gt;, BPF_MAP_TYPE_HASH, &lt;KEY-SIZE&gt;, &lt;VALUE-SIZE&gt;&gt;, &lt;MAX_ENTRIES&gt;)</div>
<div class="line">REGISTER_END()</div>
</div><!-- fragment --><ul>
<li>The C extern function must not access BPF maps that are used to implement <a class="el" href="namespace_p4.html">P4</a> tables and defined in the main C program generated from the <a class="el" href="namespace_p4.html">P4</a> language. </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.11.0-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
